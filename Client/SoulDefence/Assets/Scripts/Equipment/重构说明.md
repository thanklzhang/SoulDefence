# 装备系统重构说明

## 重构内容

### 1. EntityAttributesData 重构
**变更**：移除经验值相关字段，使其成为纯粹的属性组

**原因**：
- `EntityAttributesData` 应该是通用的属性组，可用于实体基础属性、装备属性、Buff属性等
- 经验值是实体特有的，不应该放在通用属性组中

**变更内容**：
- ✅ 移除 `baseLevel`、`expToNextLevel`、`expGainOnDeath`
- ✅ 添加战斗属性：`criticalRate`、`criticalDamage`、`damageReduction`
- ✅ 添加 `Clone()` 方法用于克隆属性
- ✅ 添加 `operator +` 用于属性叠加

**新增文件**：
- `EntityLevelData.cs` - 单独管理等级和经验数据

### 2. 装备系统使用 EntityAttributesData
**变更**：装备属性加成统一使用 `EntityAttributesData`

**原因**：
- 统一属性数据结构，减少重复代码
- 装备属性可以复用实体属性系统
- 方便后续扩展（Buff、技能加成等也可以使用同一套系统）

**变更内容**：
- ✅ `EquipmentData.qualityBonuses` 从 `QualityAttributeBonus[]` 改为 `EntityAttributesData[]`
- ✅ 删除 `QualityAttributeBonus` 类（不再需要）
- ✅ 删除 `EquipmentAttributes` 结构体（不再需要）
- ✅ `EquipmentInstance.CalculateTotalAttributes()` 返回 `EntityAttributesData`
- ✅ `EquipmentSystem` 所有属性相关方法返回 `EntityAttributesData`

### 3. 属性计算采用组合模式
**变更**：实体属性从"直接修改"改为"组合计算"

**原因**：
- 避免属性被错误修改，保持配置数据的纯净
- 清晰的属性来源追踪（基础+装备+其他）
- 方便实现属性重算和Buff系统

**变更内容**：
- ✅ `EntityAttributes` 属性访问器改为只读
- ✅ 添加 `RecalculateAttributes()` 方法重新计算总属性
- ✅ 添加 `cachedTotalAttributes` 缓存计算结果
- ✅ 添加 `owner` 引用，用于访问装备系统
- ✅ 属性计算公式：`总属性 = baseAttributesData + equipmentAttributes + otherBonuses`

**新增方法**：
- `Initialize(GameEntity entity)` - 初始化时传入所有者引用
- `RecalculateAttributes()` - 重新计算总属性
- `GetTotalAttributes()` - 获取计算后的总属性
- `SetBaseAttributesData()` - 设置基础属性（会触发重算）
- `SetLevelData()` - 设置等级数据

### 4. 装备系统接口调整
**变更**：移除直接修改属性的逻辑，改为通知重算

**变更内容**：
- ✅ 移除 `ApplyEquipmentAttributes()` 方法
- ✅ 添加 `GetTotalEquipmentAttributes()` 方法
- ✅ 添加 `NotifyAttributesChanged()` 方法
- ✅ 装备升级后调用 `NotifyAttributesChanged()` 而不是 `ApplyEquipmentAttributes()`

## 使用示例

### 创建装备配置

在Unity编辑器中：
1. 右键 -> Create -> GameConfig -> Entity -> Attributes（创建属性配置）
2. 设置武器属性（主要设置攻击相关）
3. 右键 -> Create -> GameConfig -> Equipment -> Equipment Data
4. 将属性配置拖到 Quality Bonuses[0-4] 中

### 配置实体

在Unity编辑器中选择GameEntity：
1. Base Attributes Data: 拖入基础属性配置
2. Level Data: 拖入等级配置（新增）
3. Initial Weapon: 拖入武器配置
4. Initial Armor: 拖入防具配置

### 代码中访问属性

```csharp
// 获取实体
GameEntity entity = GetComponent<GameEntity>();

// 获取总属性（基础+装备+其他）
float totalAttack = entity.Attributes.AttackPower;
float totalHealth = entity.Attributes.MaxHealth;
float critRate = entity.Attributes.CriticalRate;

// 获取基础配置属性
EntityAttributesData baseAttr = entity.Attributes.GetBaseAttributesData();

// 获取计算后的总属性
EntityAttributesData totalAttr = entity.Attributes.GetTotalAttributesData();

// 获取装备属性
EntityAttributesData equipAttr = entity.EquipmentSystem.GetTotalEquipmentAttributes();
```

### 装备升级

```csharp
// 升级武器品质
entity.EquipmentSystem.UpgradeWeaponQuality();
// 自动触发属性重算，不需要手动调用

// 查看新属性
Debug.Log($"升级后攻击力: {entity.Attributes.AttackPower}");
```

## 迁移指南

如果你已经有旧的配置文件：

1. **EntityAttributesData 配置**：
   - 经验值字段会显示为 missing，可以忽略
   - 创建新的 EntityLevelData 配置来管理经验值

2. **EquipmentData 配置**：
   - `qualityBonuses` 数组需要重新配置
   - 为每个品质等级创建 EntityAttributesData 配置
   - 将旧的属性值填入新配置中

3. **代码调整**：
   - 如果代码中直接修改了 `entity.Attributes.AttackPower = xxx`，需要改为其他方式
   - 属性修改应该通过修改配置或添加Buff实现，而不是直接赋值

## 优势

1. **清晰的数据流**：属性来源清晰（配置+装备+其他）
2. **易于扩展**：可以轻松添加更多属性来源（Buff、技能加成等）
3. **数据安全**：配置数据不会被运行时修改
4. **统一接口**：所有属性加成使用同一个数据结构
5. **方便调试**：可以清楚地看到每个来源贡献的属性值

## 注意事项

1. **属性只读**：实体属性现在是只读的，不能直接赋值
2. **重算触发**：修改装备、Buff等会自动触发属性重算
3. **配置分离**：基础属性和等级数据现在分开配置
4. **Unity编译**：重构后需要等待Unity重新编译所有脚本

